# Вход и выход из сделок

Решение войти в сделку это нечно иное как выбрать `True` или `False`.

Джесси использует `should_long()` и `should_short()` методы которые всегда возвращают булево.

Приняв решение о входе в сделку, вам нужно придумать точные цены входа и цены выхода. Джесси использует для этого методы `go_long()` и `go_short()`.

## should_long()

**возвращемый тип**: bool

Предполагая, что позиция в настоящее время закрыта, открывает длинную позицию.

Пример:

```py
def should_long(self):
    # возвращет истину, если текущая свеча является бычьей свечей
    if self.close > self.open:
        return True

    return False
```

## should_short()

**возвращемый тип**: bool

Предполагая, что позиция в настоящее время закрыта, открывает короткую позицию.

```py
def should_short(self):
    # возвращет истину, если текущая свеча является медвежьей свечей
    if self.close < self.open:
        return True

    return False
```

::: warning Внимание
Очевидно, что вы не можете одновременно открывать и короткую, и длинную позицию. Следовательно, `should_long()` и `should_short()` не могут одновременно возвращать True.
:::

::: warning Внимание
`should_long()` and `should_short()` только для входа в сделку. Это означает, что они будут запрашиваться на каждой новой свече, только если ни одна позиция не открыта, и ни один ордер не активен.

Если вы хотите динамически закрывать сделки то, [update_position()](/docs/strategies/entering-and-exiting.html#update-position) то, что вы ищите. 
:::

## go_long()

Внутри `go_long()` метода вы ставите entry_price (цену покупки, точку входа), quantity (количество, сколько вы покупаете), the stop-loss и take-profit (стоп-лос и тейк-профит точки выхода) объемом и ценой. Базовый синтаксис:

```py
def go_long(self):
    self.buy = qty, entry_price
    self.stop_loss = qty, stop_loss_price
    self.take_profit = qty, take_profit_price
```

`qty`, `entry_price`, `stop_loss_price`, и `take_profit_price` это заполнители, могут быть какими вы пожелаете; но `self.buy`, `self.stop_loss`, и `self.take_profit` специальные переменные которые использует Джесси; они должены быть одинаковы.

Рабочий пример будет такой:

```py
def go_long(self):
    qty = 1

    self.buy = qty, self.price
    self.stop_loss = qty, self.low - 10
    self.take_profit = qty, self.high + 10
```

::: tip Умная система выставления ордеров
Обратите внимание, что нам не нужно было определять, какой тип заказа использовать. Джесси достаточно умна, чтобы самостоятельно определять тип ордера.

Например, если это длинная позиция, вот как рассуждает Джесси:

-   MARKET order: if `entry_price == current_price`
-   LIMIT order: if `entry_price < current_price`
-   STOP order: if `entry_price > current_price`

:::

## go_short()

Так же [go_long()](#go-long) использует `self.sell` для входа в рынок в место `self.buy`:

```py
def go_short(self):
    self.sell = qty, entry_price
    self.stop_loss = qty, stop_loss_price
    self.take_profit = qty, take_profit_price
```

Рабочий пример будет такой:

```py
def go_short(self):
    qty = 1

    # открывает позицию с типом ордера MARKET
    self.sell = qty, self.price
    self.stop_loss = qty, self.high + 10
    self.take_profit = qty, self.low - 10
```

<!-- ## Margin trading

`should_short()` and `go_short()` are used for shorting, which only possible if the market you're trading supports margin trading. In case it doesn't, you can turn off shorting by:

```py
def should_short(self):
    return False

def go_short(self):
    pass
``` -->

## should_cancel()

**возвращаемый тип**: bool

Этот метод спрашивает вас: ордер на открытую позицию уже отправлен, но _еще не выполнен_, следует ли его отменить?

::: tip Совет

После подачи ордеров на открытие новых позиций вы либо сразу войдете в позицию с помощью рыночного ордера, либо вам придется подождать, пока ваш лимитный / стоп-ордер будет исполнен. Этот метод используется для второго сценария.

:::

Хорошим примером было бы торговать если мы пытаемся открыть позицию, когда цена продолжается восходящий тренд:

```py
def should_long(self):
    return True

def go_long(self):
    qty = 1
    entry = self.high + 2

    self.buy = qty, entry
    self.stop_loss = qty, entry - 10
    self.take_profit = qty, entry + 10
```

Поскольку цена входа выше текущей цены, Джесси отправит стоп ордер для входа в торговлю. Если цена действительно поднимается и все в порядке, но что, если пропущена новая свеча, и цена идет вниз? Тогда мы бы хотели, чтобы предыдущий заказ был отменен, а новый заказ, был отправлен на основе высокой цены новой свечи.

Для этого нам придется указать `should_cancel()`:

```py
def should_cancel(self):
    return True
```

В вашей стратегии, вам может потребоваться выполнить некоторую проверку, прежде чем решить, держать предыдущий заказ открытым еще или он уже должен быть отменен.

::: tip
`should_cancel()` только решает, отменить или нет. Это не влияет на ваш выход по (take-profit и stop-loss) ордерам.
:::

## Вход и/или выход в нескольких точках

До сих пор мы определили пример одновходную и одновыходную  стратегию используя `go_long()` и `go_short()` методы. Этого может быть недостаточно для ваших стратегий. 

Для входа/выхода в одной точке мы обозначаем **один картеж**. Для входа/выхода в нескольких точках все что нужно сделать так это переписать на использование **списка картежей**.

Пример забирания прибыли в двух точках:

```py
def go_long():
    qty = 1

    self.buy = qty, 100
    self.stop_loss = qty, 80

    # take-profit в двух точках
    self.take_profit = [
        (qty/2, 120),
        (qty/2, 140)
    ]
```

Мы могли бы сделать то же самое для `self.stop_loss` если это имеет смысл в вашей стратегии.

Пример входа в сделку по двум точкам:

```py
def go_long():
    qty = 1

    # открыть позицию при $120 и увеличить ее при $140
    self.buy = [
        (qty/2, 120),
        (qty/2, 140)
    ]
    self.stop_loss = qty, 100
    self.take_profit = qty, 160
```

Что, если мы не знаем о нашей точной точке выхода на момент входа в торговлю? Например, это общий случай в стратегиях следования тренду, выходить когда тенденция остановилась. 

Следующий раздел вводит концепцию [событий](./events.html) заполняет эту потребность.

## prepare()
Как объяснялось на [схеме](./), первый метод который вызывается когда получается новая свеча. Это используется для обновления `self.vars` (пользовательских переменных) или любых других действий которые по вашему нужно сделать после выполенния вашей стратегии. 

**смотри так же**: [переменные](./api.html#vars)


## update_position() 
Предполагая, что есть открытая сделка, этот метод используется для обновления точек выхода или чтобы добавть до размера позиции если необходимо.


:::tip Совет
Если ваша стратегия динамически выходит динамически (например, если во время входа в торговлю вы не знаете цену на получение прибыли), то вам определенно нужно использовать `update_position`.
:::

**Пример #1:** Выход сделки, осуществляя трейлинг-стоп для получения прибыли: 
```py 
def update_position(self):
    qty = self.position.qty 

    # ставит цену stop-loss $10 от выше/ниже от текущей цвечи
    if self.is_long:
        self.take_profit = qty, self.high - 10
    else:
        self.take_profit = qty, self.low + 10
```

**Пример #3:** Ликвидация открытой сделки в определенном состоянии. В этом случае, есть [ликвидация](/ru/strategies/api.html#liquidate) если мы в долгой позиции и RSI достигает 100: 
```py 
def update_position(self):
    if self.is_long and ta.rsi(self.candles) == 100:
        self.liquidate()
```

**Пример #3:** Удвоение размера моей длинной позиции если RSI показывает перепроданность и я сижу в более чем 5% прибыли:
```py 
def update_position(self):
    if self.is_long:
        if self.position.pnl_percentage > 5 and ta.rsi(self.candles) < 30:
            # удвоение размера уже открытой позиции от текущей цены (с помощью MARKET сделки)
            self.buy = self.position.qty, self.price
```

## \_\_init\_\_()
`__init__` не новая концепция. Это конструктор Python класса. Стратегии Джесси это классы Python, следовательно вы можете использовать метод `__init__` для действия которое должны быть выполнено в начале стратегии и только один раз. 

Вы можете сказать `__init__` в противоположность методу [terminate()](./entering-and-exiting.html#terminate) в вашей стратегии Джесси. 

::: warning Внимание
Помните в начале метода `__init__` должен быть вызов `super().__init__()`, иначе вы получите ошибку.
:::

```py
def __init__(self):
    super().__init__()

    print('инициализация класса стратегии')
```


## terminate() 
Есть случаи, когда вам нужно сказать Джессе, чтобы выполнить задачу прямо до того, как будет уничтожена (как завершении симуляции бектеста). Примеры такой задачи логировали бы значения или сохраняли модель обучения машины.

Скажем `terminate` противоположность методу [\_\_init\_\_](./entering-and-exiting.html#init) стратегии Джесси.

```py
def terminate(self):
    print('Бэктест завершен.')
```